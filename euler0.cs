using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace project_Euler
{
    public static class euler0
    {



        /*
         *  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
         *  Find the sum of all the multiples of 3 or 5 below 1000.
         */
        public static void challenge1(int max)
        {
            int sum = 0;
            for (int i = 1; i < max; i++)
            {
                if (i % 3 == 0 || i % 5 == 0) sum += i;
            }
            Console.WriteLine("TOTAL : {0}", sum);
        }



        /*
         *  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
         *   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
         *  By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
         */
        public static void challenge2(int max)
        {
            List<int> fibo = new List<int> { 1, 2 };
            int sum = fibo.Last();
            do
            {
                //adds up 2 last numbers
                fibo.Add(fibo.Last() + fibo[fibo.Count - 2]);
                //checks if the last number is even
                if (fibo.Last() % 2 == 0) sum += fibo.Last();

            } while (fibo.Last() < max);
            Console.WriteLine("TOTAL : {0}", sum);
        }



        /*
        *  The prime factors of 13195 are 5, 7, 13 and 29.
        *  What is the largest prime factor of the number 600851475143 ?
        */
        public static long m_num;
        public static void challenge3(long num)
        {
            // help here: http://www.mathblog.dk/project-euler-problem-3/

            m_num = num;

            //used a thread for the lulz
            //I thought it would be long...
            Thread t = new Thread(calculatePrime);
            t.Start();
            Console.WriteLine("Calculating...");
        }

        private static void calculatePrime()
        {
            bool isPrime = true;
            long maxPrime = 0;

            for (long j = 2; j < (m_num / j) + 1; j++)
            {
                //not a factor
                if ((m_num % j != 0))
                {
                    continue;
                }

                //check if factors are prime
                for (int i = 2; i < (j / i) + 1; i++)
                {
                    if (j % i == 0) isPrime = false;
                }

                if (isPrime) maxPrime = j;

            }
            Console.WriteLine("Largest prime factor : {0}", maxPrime);
        }



        /*
         *  A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
         *  Find the largest palindrome made from the product of two 3-digit numbers.
         */

        public static void challenge4()
        {

            int biggest = 0;
            for (int i = 100; i < 1000; i++)
            {
                for (int j = 100; j < 1000; j++)
                {
                    int product = i * j;

                    //I suck at math so I changed the product to String
                    string sProduct = product.ToString();
                    string part1 = sProduct.Substring(0, sProduct.Length / 2);
                    string part2 = sProduct.Substring(3, sProduct.Length / 2);

                    //I reverse part2 and compare them
                    if (part1.Equals(new string(part2.ToCharArray().Reverse().ToArray())))
                    {
                        //because of the 2 -for- loops I loop back to smaller numbers
                        //I need to update biggest only if the answer is bigger
                        if (product > biggest) biggest = product;
                    }
                }
            }
            Console.WriteLine("BIGGEST : {0}", biggest);
        }



      /*
       *  2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
       *  What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
       */

        public static void challenge5(int max)
        {
            int smallest = 0;
            int num = max;
            bool isContinued = true;
            do
            {
                num++;
                for (int i = 1; i < max + 1; i++)
                {

                    if (num % i != 0) break;
                    smallest = num;
                    if (i == max - 1) isContinued = false;
                }
            } while (isContinued);
            Console.WriteLine("SMALLEST : {0}", smallest);
        }



        /*
         * The sum of the squares of the first ten natural numbers is,
         * 
            1^2 + 2^2 + ... + 10^2 = 385
            The square of the sum of the first ten natural numbers is,

            (1 + 2 + ... + 10)^2 = 552 = 3025
            Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.

            Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
         */

        public static void challenge6(int max)
        {
            int sumSquares = 0;

            long squareSum = 0;

            for (int i = 1; i < max + 1; i++)
            {
                sumSquares += i * i;
                squareSum += i;
            }
            squareSum *= squareSum;

            Console.WriteLine("Difference : {0}", squareSum - sumSquares);
        }



        /*
         *  By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

            What is the 10 001st prime number?
         */

        public static void challenge7(int primePosition)
        {
            int currentNum = 2;
            List<int> primeList = new List<int>();
            bool isPrime;
            do
            {
                isPrime = true;
                //loop through value from 2 to currentNum-1
                for (int j = 2; j < currentNum; j++)
                {
                    if (currentNum % j == 0) isPrime = false;
                }
                if (isPrime) primeList.Add(currentNum);
                currentNum++;

            } while (primeList.Count != primePosition);

            Console.WriteLine(primeList.Last());
        }



        /*
        * The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
        * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
        */

        public static void challenge8(int adjacentDigits)
        {
            long max_product = 0;
            string theDigit = "73167176531330624919225119674426574742355349194934" +
                                "96983520312774506326239578318016984801869478851843" +
                                "85861560789112949495459501737958331952853208805511" +
                                "12540698747158523863050715693290963295227443043557" +
                                "66896648950445244523161731856403098711121722383113" +
                                "62229893423380308135336276614282806444486645238749" +
                                "30358907296290491560440772390713810515859307960866" +
                                "70172427121883998797908792274921901699720888093776" +
                                "65727333001053367881220235421809751254540594752243" +
                                "52584907711670556013604839586446706324415722155397" +
                                "53697817977846174064955149290862569321978468622482" +
                                "83972241375657056057490261407972968652414535100474" +
                                "82166370484403199890008895243450658541227588666881" +
                                "16427171479924442928230863465674813919123162824586" +
                                "17866458359124566529476545682848912883142607690042" +
                                "24219022671055626321111109370544217506941658960408" +
                                "07198403850962455444362981230987879927244284909188" +
                                "84580156166097919133875499200524063689912560717606" +
                                "05886116467109405077541002256983155200055935729725" +
                                "71636269561882670428252483600823257530420752963450";

            for (int i = 0; i < theDigit.Length - adjacentDigits; i++)
            {
                string subDigit = theDigit.Substring(i, adjacentDigits);
                long product = 1;
                for (int j = 0; j < subDigit.Length; j++)
                {
                    product *= Convert.ToInt32(subDigit[j].ToString());
                }
                if (product > max_product) max_product = product;
            }

            Console.WriteLine("MAX PRODUCT : {0}", max_product);
        }



        /*
         * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

            a2 + b2 = c2
            For example, 32 + 42 = 9 + 16 = 25 = 52.

            There exists exactly one Pythagorean triplet for which a + b + c = 1000.
            Find the product abc.
         */

        public static void challenge9(int result)
        {
            bool stop = false;
            int ma = 0, mb = 0, mc = 0;
            for (int a = 1; a < result + 1; a++)
            {
                ma = a;
                for (int b = 2; b < result + 1; b++)
                {
                    mb = b;
                    for (int c = 3; c < result + 1; c++)
                    {
                        mc = c;
                        //check both condition
                        if (a + b + c == result && ((a * a) + (b * b) == (c * c))) stop = true;
                        if (stop) break;
                    }
                    if (stop) break;
                }
                if (stop) break;
            }
            Console.WriteLine("The triplet is {0},{1},{2} and the product is {3}", ma, mb, mc, ma * mb * mc);
        }



        /*
         *  The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
            Find the sum of all the primes below two million.
         */

        public static void challenge10(int max)
        {
            long primeSum = 0;

            for (int i = 2; i < max; i++)
            {

                bool isPrime = true;

                //j<(i/j)+1
                //This is because for example, if -i- can't be divided by 2 without a rest
                //the maximum becomes i/2 (useless to go over that)
                //if -i- can't be divided by 3, the maximum becomes i/3 and so on.
                //this speeds up the process quite fast !
                //+1 is used because a division between 2 int with a rest will round down.
                for (int j = 2; j < (i / j) + 1; j++)
                {
                    if ((i % j == 0))
                    {
                        isPrime = false;
                        break;
                    }
                }

                if (isPrime)
                {
                    primeSum += i;
                    //Console.WriteLine(i);
                }
            }

            Console.WriteLine("The sum of prime number below {0} is {1}", max, primeSum);
        }
    }
}
